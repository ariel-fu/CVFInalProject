p3b CONCLUSIONS.TXT

Complete p3b and answer the following questions using results of running JDK Mission Control to justify your conclusions..

1) What can you tell about the performance of your hash table implementation compared to Java's tree map? 
Explain why (or when) your hash table is better or worse than Java's Tree Map.
According to the Stack trace, the the (tree map) put(Object, Object) method took more CPU cycles (2600) compared to the hashtable insert (2334). Additionally, the tree map's put method took about 96.4% of the CPU. Meanwhile, my hash table's insert method took about 60% of the CPU. However, the most allocations involve my hashtable and inserting new key-value pairs, and it takes up most of the heap space. Contrastly, the tree map's put method takes up very little heap space.  Therefore, it is reasonable to conclude that my hash table has better performance compared to Java's Tree Map, but the tree map has better memory allocation and memory usage compared to my hash table.


2) What did you observe in jdk mission control to come to the conclusion above?
I looked at the stack trace and the CPU usage chart. 


3) SCREENSHOT_001.PNG NOTES: Briefly describe what this image 001 shows
The blue bar represents the number of allocations made by inserting into the hash table. It made 435 allocations and increased the heap usage tremendously. This screenshot was used to determine that my hash table takes more allocations and heap space compared to the tree map.



4) SCREENSHOT_002.PNG NOTES: Briefly describe what this image 002 shows
The screenshot shows the Stack Trace from the JDK Mission Control. It was used to determine that the tree map takes more CPU cycles compared to my hash table.


5) Describe other screenshots if you include them in your submission.


